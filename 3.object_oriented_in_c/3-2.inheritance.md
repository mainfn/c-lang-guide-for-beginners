상속은 객체 지향의 핵심 중 하나로,

기존 클래스를 **확장**하는 개념이다.

이를 통해 중복 제거가 가능하다.

B가 A의 subtype일 때, **B is a A** 관계로 본다.

B가 학생, A가 사람이면 **학생 is a 사람**인 것이다.

모든 학생은 사람이기 때문에 참이다.

반대의 경우는 성립하지 않는다.

**사람 is a 학생**

사람은 학생일 수도 있고 아닐 수도 있기 때문이다.

---

# Java에서의 상속

**Java**는 가장 대표적인 객체 지향 언어로,

이 글을 보는 대부분의 사람들이 한번쯤은 사용해봤을 것이다.

`Person`과 `Student`을 간단한 **Java** 코드로 작성했다.

```java filename="Person.java" copy
public class Person {
    private String name;
    private int age;

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public final void introduce() {
        System.out.printf("name is %s, age is %d\n", name, age);
    }
}
```

```java filename="Person.java" copy
public final class Student extends Person {
    private int grade;

    public int getGrade() {
        return grade;
    }

    public Student(String name, int age, int grade) {
        super(name, age);
        this.grade = grade;
    }
}
```

이제 `Student` 인스턴스는 `Person` 클래스의 모든 속성을 상속 받는다.

코드 상으로는 보이지 않지만 핵심은 `Person`의 모든 멤버 변수와 메소드가 `Student`에도 존재한다는 것이다.

이를 **C**로 작성해보겠다.

---

# C에서의 상속

```c filename="inheritance.h" copy
// struct
typedef struct {} person_t;
typedef struct {} student_t;

// fn pointer aliases
typedef void (*introduce_fn)(person_t* p);
typedef const char* (*get_name_fn)(person_t* p);
typedef int (*get_age_fn)(person_t* p);
typedef int (*get_grade_fn)(student_t* s);

// memory allocators
person_t* new_person();
student_t* new_student();

// constructors
void construct_person(person_t* p, const char* name, int age);
void construct_student(student_t* s, const char* name, int age, int grade);

// destructors
void destruct_person(person_t* p);
void destruct_student(student_t* s);

// methods
void introduce(person_t* p);
const char* get_name(person_t* p);
int get_age(person_t* p);
int get_grade(student_t* s);
```

`inheritance.h` 헤더 파일에 생성자, 소멸자, 함수 헤더 등을 선언했다.

직전 글에서 **C**의 캡슐화를 봤을 때랑 별반 다르지 않다.

한가지 추가된 것은 함수 포인터 타입이 추가 되었다는 것이다.

```c filename="inheritance.c" copy
#include "inheritance.h"

#include <printf.h>
#include <stdlib.h>
#include <string.h>

// structs
typedef struct {
    char* name;
    int age;
    introduce_fn introduce;
    get_name_fn get_name;
    get_age_fn get_age;
} __person_t;

typedef struct {
    __person_t person;
    int grade;
    get_age_fn get_age;
} __student_t;

// memory allocators
person_t* new_person() {
    return malloc(sizeof(__person_t));
}

student_t* new_student() {
    return malloc(sizeof(__student_t));
}

char* __new_name(const char* name) {
    return malloc(strlen(name) + 1);
}

// constructors
void construct_person(person_t* p, const char* name, int age) {
    __person_t* __p = p;

    __p->name = __new_name(name);
    __p->age = age;
    __p->introduce = introduce;
    __p->get_name = get_name;
    __p->get_age = get_age;

    strcpy(__p->name, name);
}

void construct_student(student_t* s, const char* name, int age, int grade) {
    person_t* p = s;
    construct_person(p, name, age);

    __student_t* __s = s;
    __s->grade = grade;
    __s->get_grade = get_grade;
}

// destructors
void destruct_person(person_t* p) {
    __person_t* __p = p;

    free(__p->name);
    free(p);
}

void destruct_student(student_t* s) {
    destruct_person(s);
}

// methods
void introduce(person_t* p) {
    __person_t* __p = p;

    printf("name is %s, age is %d\n", __p->name, __p->age);
}

const char* get_name(person_t* p) {
    __person_t* __p = p;

    return __p->name;
}

int get_age(person_t* p) {
    __person_t* __p = p;

    return __p->age;
}

int get_grade(student_t* s) {
    __student_t* __s = s;

    return __s->grade;
}
```

실제 구현이 들어 있는 inheritance.c 파일의 내용이다.

역시 이전에 작성한 것과 별반 다를 바 없다.

---

```c filename="inheritance.c" copy
// ...
int main() {
  student_t* s = new_student();
  construct_student(s, "degiri", 16, 3);

  person_t* p = s;

  __person_t* __p = s;
  __student_t* __s = s;
}
```

위 코드와 메모리 뷰를 보면 상속의 원리가 정확히 이해될 것이다.

`new_student` 함수로 `__student_t` 구조체의 크기만큼 Heap에 동적 할당한다.

이 때, `__student_t` 구조체의 크기는 56byte다.

`__person_t` 구조체 크기가 36byte(8byte 함수 포인터 3개(24byte) + `char*` 포인터(8byte) + `int`(4byte))

그런데 현재 작업 중인 컴퓨터가 64bit 플랫폼이므로 4byte 메모리 패딩이 들어가서 실제 메모리 뷰 상에서는 40byte가 되었다.

계산이 귀찮으면 그냥 `__person_t` 구조체 크기가 40byte라고 생각하자.

`__student_t` 구조체는 `__person_t`를 내부에 가지고 있으므로 기본으로 40byte를 깔고 갈 것이다.

거기에 `int`(4byte), 함수 포인터(8byte)를 단순 계산하니 52byte가 된다.

역시 이번에도 메모리 패딩이 들어가서 56byte가 되었다.





{/* 
```c

int main() {
  person_t* p = new_person();
  student_t* s = new_student();

  construct_person(p, "zeral", 18);
  construct_student(s, "degiri", 16, 3);

  introduce(p);
  const char* person_name = get_name(p);
  int person_age = get_age(p);

  person_t* p2 = s;
  introduce(p2);
  const char* student_name = get_name(p2);
  int student_age = get_age(p2);

  return 0;
}
``` */}
